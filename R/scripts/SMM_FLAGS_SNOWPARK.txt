{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Snowflake Snowpark — SMM & Chronic Flags Notebook\n",
    "_Run these cells inside a **Snowflake Python Notebook** (no pip, no SQL cells needed)._"
    ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 1 — Get Snowpark session and core imports (no pandas)\n",
    "from snowflake.snowpark.context import get_active_session\n",
    "from snowflake.snowpark.functions import (\n",
    "    col, lit, upper, regexp_replace, regexp_like, coalesce,\n",
    "    when, max as sp_max, sum as sp_sum\n",
    ")\n",
    "from snowflake.snowpark.types import StringType\n",
    "import re\n",
    "\n",
    "session = get_active_session()\n",
    "\n",
    "print(\"Warehouse:\", session.get_current_warehouse())\n",
    "print(\"Database :\", session.get_current_database())\n",
    "print(\"Schema   :\", session.get_current_schema())"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Configure your table names"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 2 — Point to your two Snowflake tables (edit names if different)\n",
    "MM_TABLE  = \"MM_RAW\"          # long-format table with DIAGNOSIS_CODE_1..10 (+ optional DESCRIPTION cols)\n",
    "SMM_TABLE = \"SMM_REFERENCE\"   # SMM lookup: Flag#, Severe_Maternal_Morbidity_Indicator, Diagnosis_or_Procedure, ICD-10, Definition\n",
    "\n",
    "mm_raw  = session.table(MM_TABLE)\n",
    "smm_ref = session.table(SMM_TABLE)\n",
    "\n",
    "print(\"MM columns :\", mm_raw.schema.names)\n",
    "print(\"SMM columns:\", smm_ref.schema.names)\n",
    "\n",
    "# Peek a few rows (Snowpark prints)\n",
    "mm_raw.show(3)\n",
    "smm_ref.show(3)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Utilities to normalize names and detect numbered columns"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 3 — Helpers\n",
    "\n",
    "def norm_key(s: str) -> str:\n",
    "    \"\"\"\n",
    "    Normalize a column name for matching:\n",
    "    - uppercase\n",
    "    - strip spaces\n",
    "    - replace any non-alnum with underscore\n",
    "    - collapse multiple underscores\n",
    "    \"\"\"\n",
    "    s = re.sub(r\"\\s+\", \"\", s.upper())\n",
    "    s = re.sub(r\"[^A-Z0-9]+\", \"_\", s)\n",
    "    s = re.sub(r\"_+\", \"_\", s).strip(\"_\")\n",
    "    return s\n",
    "\n",
    "def resolve_col(df, target_names):\n",
    "    \"\"\"\n",
    "    Return the actual column name from df.schema.names that matches any of target_names\n",
    "    (case-insensitive, tolerant to punctuation like '-' '#', spaces).\n",
    "    target_names can be a string or list of strings.\n",
    "    \"\"\"\n",
    "    if isinstance(target_names, str):\n",
    "        target_names = [target_names]\n",
    "    want = {norm_key(t): t for t in target_names}\n",
    "    candidates = {norm_key(c): c for c in df.schema.names}\n",
    "    # exact normalized match\n",
    "    for nk in want.keys():\n",
    "        if nk in candidates:\n",
    "            real = [c for c in df.schema.names if norm_key(c) == nk][0]\n",
    "            return real\n",
    "    # fuzzy contains\n",
    "    for c in df.schema.names:\n",
    "        if any(norm_key(t) in norm_key(c) for t in target_names):\n",
    "            return c\n",
    "    raise ValueError(f\"Could not resolve any of {target_names} in columns: {df.schema.names}\")\n",
    "\n",
    "def numbered_cols(df, prefix: str):\n",
    "    \"\"\"\n",
    "    Finds columns like DIAGNOSIS_CODE_1..10 or DIAGNOSIS_DESCRIPTION_SHORT_1..10\n",
    "    Returns them sorted by numeric suffix.\n",
    "    \"\"\"\n",
    "    cols = df.schema.names\n",
    "    out = []\n",
    "    pat = re.compile(rf\"^{prefix}_(\\d+)$\", flags=re.IGNORECASE)\n",
    "    for c in cols:\n",
    "        m = pat.match(c)\n",
    "        if m:\n",
    "            out.append((int(m.group(1)), c))\n",
    "    out.sort(key=lambda t: t[0])\n",
    "    return [c for _, c in out]"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Map SMM reference columns & detect DIAG code/description columns"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 4 — Resolve exact SMM headers (your provided names)\n",
    "# SMM columns present: Flag#, Severe_Maternal_Morbidity_Indicator, Diagnosis_or_Procedure, ICD-10, Definition\n",
    "\n",
    "smm_flag_col = resolve_col(smm_ref, [\"Flag#\", \"Flag\"])\n",
    "smm_name_col = resolve_col(smm_ref, [\"Severe_Maternal_Morbidity_Indicator\", \"SMM Indicator\"])\n",
    "smm_diag_col = resolve_col(smm_ref, [\"Diagnosis_or_Procedure\", \"Diagnosis or Procedure\"])\n",
    "smm_icd_col  = resolve_col(smm_ref, [\"ICD-10\", \"ICD_10\"])\n",
    "smm_def_col  = resolve_col(smm_ref, [\"Definition\"])\n",
    "\n",
    "print(\"SMM mapped columns:\")\n",
    "print(\"  Flag     :\", smm_flag_col)\n",
    "print(\"  Name     :\", smm_name_col)\n",
    "print(\"  Dx/Proc  :\", smm_diag_col)\n",
    "print(\"  ICD-10   :\", smm_icd_col)\n",
    "print(\"  Def      :\", smm_def_col)\n",
    "\n",
    "# Detect DIAGNOSIS_CODE_1..10 and DIAGNOSIS_DESCRIPTION_SHORT_1..10 on MM\n",
    "code_cols = numbered_cols(mm_raw, \"DIAGNOSIS_CODE\")\n",
    "desc_cols = numbered_cols(mm_raw, \"DIAGNOSIS_DESCRIPTION_SHORT\")\n",
    "\n",
    "if not code_cols:\n",
    "    raise ValueError(\"No DIAGNOSIS_CODE_# columns found on MM table.\")\n",
    "\n",
    "print(\"Detected DIAG code columns:\", code_cols)\n",
    "print(\"Detected DIAG desc columns:\", desc_cols or \"(none)\")"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## UNPIVOT the 10 diagnosis code columns (and optional descriptions)"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 5 — UNPIVOT\n",
    "# Codes → (DIM_MEMBER_KEY, CODE_SLOT, ICD_CODE)\n",
    "codes_sql = \", \".join(code_cols)\n",
    "mm_codes_long = session.sql(f\"\"\"\n",
    "    SELECT DIM_MEMBER_KEY,\n",
    "           CODE_SLOT,\n",
    "           ICD_CODE\n",
    "    FROM {mm_raw.quoted_name}\n",
    "    UNPIVOT( ICD_CODE FOR CODE_SLOT IN ({codes_sql}) )\n",
    "\"\"\")\n",
    "\n",
    "# Descriptions (optional) → join by slot number\n",
    "if desc_cols:\n",
    "    descs_sql = \", \".join(desc_cols)\n",
    "    mm_desc_long = session.sql(f\"\"\"\n",
    "        SELECT DIM_MEMBER_KEY,\n",
    "               DESC_SLOT,\n",
    "               ICD_DESC\n",
    "        FROM {mm_raw.quoted_name}\n",
    "        UNPIVOT( ICD_DESC FOR DESC_SLOT IN ({descs_sql}) )\n",
    "    \"\"\")\n",
    "\n",
    "    # Extract numeric suffix to align slots\n",
    "    mm_codes_long = mm_codes_long.with_column(\"SLOT_NUM\", regexp_replace(col(\"CODE_SLOT\"), r\"[^0-9]\", \"\"))\n",
    "    mm_desc_long  = mm_desc_long.with_column(\"SLOT_NUM\", regexp_replace(col(\"DESC_SLOT\"), r\"[^0-9]\", \"\"))\n",
    "\n",
    "    mm_codes_long = mm_codes_long.join(mm_desc_long, on=[\"DIM_MEMBER_KEY\",\"SLOT_NUM\"], how=\"left\")\n",
    "else:\n",
    "    mm_codes_long = mm_codes_long.with_column(\"ICD_DESC\", lit(None).cast(StringType()))\n",
    "\n",
    "mm_codes_long.show(5)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Normalize ICD codes; standardize SMM DX rows; exact join"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 6 — Normalize and join\n",
    "# Normalize ICD in member data\n",
    "mm_codes_long = mm_codes_long.with_column(\n",
    "    \"ICD_CODE_NORM\",\n",
    "    upper(regexp_replace(col(\"ICD_CODE\"), r\"\\s+\", \"\"))\n",
    ")\n",
    "\n",
    "# Standardize SMM (keep DIAGNOSIS rows only)\n",
    "smm_ref_std = (\n",
    "    smm_ref.select(\n",
    "        col(smm_diag_col).alias(\"DIAGNOSIS_OR_PROCEDURE\"),\n",
    "        col(smm_icd_col).alias(\"ICD_10\"),\n",
    "        col(smm_name_col).alias(\"SMM_INDICATOR\")\n",
    "    )\n",
    "    .with_column(\"ICD_10_NORM\", upper(regexp_replace(col(\"ICD_10\"), r\"\\s+\", \"\")))\n",
    "    .filter(upper(col(\"DIAGNOSIS_OR_PROCEDURE\")) == lit(\"DX\"))\n",
    "    .select(\"ICD_10_NORM\", \"SMM_INDICATOR\")\n",
    "    .distinct()\n",
    ")\n",
    "\n",
    "# Exact match on normalized codes\n",
    "smm_matches_join = mm_codes_long.join(\n",
    "    smm_ref_std,\n",
    "    on=(mm_codes_long[\"ICD_CODE_NORM\"] == smm_ref_std[\"ICD_10_NORM\"]),\n",
    "    how=\"left\"\n",
    ")\n",
    "\n",
    "smm_matches_join.show(5)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Chronic condition flags (from description keywords and ICD families)"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 7 — Chronic condition flags\n",
    "\n",
    "# Fallback text: description else SMM indicator\n",
    "smm_matches_join = smm_matches_join.with_column(\n",
    "    \"DESC_UP\",\n",
    "    upper(coalesce(col(\"ICD_DESC\"), col(\"SMM_INDICATOR\")))\n",
    ")\n",
    "\n",
    "# Description keyword patterns\n",
    "cc_desc_patterns = {\n",
    "    \"diabetes\":      r\".*\\bDIABETES\\b.*\",\n",
    "    \"hypertension\":  r\".*\\bHYPERTENSION\\b.*\",\n",
    "    \"asthma\":        r\".*\\bASTHMA\\b.*\",\n",
    "    \"copd\":          r\".*\\bCOPD\\b.*\",\n",
    "    \"depression\":    r\".*\\bDEPRESSION\\b.*\",\n",
    "    \"heart_failure\": r\".*\\bHEART\\s*FAILURE\\b.*\",\n",
    "    \"ischemic\":      r\".*\\bISCHEMIC\\b.*\",\n",
    "    \"stroke\":        r\".*\\bSTROKE\\b.*\",\n",
    "}\n",
    "\n",
    "# ICD family patterns\n",
    "cc_icd_patterns = {\n",
    "    \"diabetes\":      r\"^E0[8-9].*|^E1[0-3].*\",\n",
    "    \"hypertension\":  r\"^I1[0-6].*\",\n",
    "    \"asthma\":        r\"^J45.*\",\n",
    "    \"copd\":          r\"^J44.*\",\n",
    "    \"depression\":    r\"^F3[2-3].*\",\n",
    "    \"heart_failure\": r\"^I50.*|^I11\\.0.*|^I13\\.(0|2).*\",\n",
    "    \"ischemic\":      r\"^I2[0-5].*\",\n",
    "    \"stroke\":        r\"^I6[0-9].*\",\n",
    "}\n",
    "\n",
    "# Add description-based flags\n",
    "for nm, pat in cc_desc_patterns.items():\n",
    "    smm_matches_join = smm_matches_join.with_column(\n",
    "        f\"HAS_{nm.upper()}_DESC\",\n",
    "        when(regexp_like(col(\"DESC_UP\"), pat), lit(1)).otherwise(lit(0))\n",
    "    )\n",
    "\n",
    "# Add ICD-based flags\n",
    "for nm, pat in cc_icd_patterns.items():\n",
    "    smm_matches_join = smm_matches_join.with_column(\n",
    "        f\"HAS_{nm.upper()}_ICD\",\n",
    "        when(regexp_like(col(\"ICD_CODE_NORM\"), pat), lit(1)).otherwise(lit(0))\n",
    "    )\n",
    "\n",
    "smm_matches_join.show(5)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## Aggregate to one row per member (FLAG_SMM_* + chronic flags)"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 8 — Wide build\n",
    "# Safe SMM key for column names\n",
    "smm_matches_join = smm_matches_join.with_column(\n",
    "    \"SMM_KEY\",\n",
    "    upper(regexp_replace(coalesce(col(\"SMM_INDICATOR\"), lit(\"\")), r\"[^A-Z0-9]+\", \"_\"))\n",
    ")\n",
    "\n",
    "# Base: the set of members\n",
    "wide_base = smm_matches_join.select(\"DIM_MEMBER_KEY\").distinct()\n",
    "\n",
    "# Chronic flags aggregation: MAX across rows per member\n",
    "flag_cols = [c for c in smm_matches_join.schema.names if c.startswith(\"HAS_\")]\n",
    "chronic_wide = (\n",
    "    smm_matches_join\n",
    "    .group_by(\"DIM_MEMBER_KEY\")\n",
    "    .agg(*[sp_max(col(c)).alias(c) for c in flag_cols])\n",
    ")\n",
    "\n",
    "# Determine all SMM keys present\n",
    "smm_keys = [\n",
    "    r[\"SMM_KEY\"] for r in smm_matches_join\n",
    "    .select(\"SMM_KEY\").filter(col(\"SMM_KEY\") != lit(\"\"))\n",
    "    .distinct().collect()\n",
    "]\n",
    "\n",
    "# Conditional aggregation to create FLAG_SMM_<KEY> columns\n",
    "if smm_keys:\n",
    "    smm_agg_exprs = [\n",
    "        sp_max(when(col(\"SMM_KEY\") == lit(k), lit(1)).otherwise(lit(0))).alias(f\"FLAG_SMM_{k}\")\n",
    "        for k in smm_keys\n",
    "    ]\n",
    "    smm_wide = smm_matches_join.group_by(\"DIM_MEMBER_KEY\").agg(*smm_agg_exprs)\n",
    "else:\n",
    "    smm_wide = wide_base\n",
    "\n",
    "# Final wide\n",
    "final_wide = (\n",
    "    wide_base\n",
    "    .join(chronic_wide, on=\"DIM_MEMBER_KEY\", how=\"left\")\n",
    "    .join(smm_wide, on=\"DIM_MEMBER_KEY\", how=\"left\")\n",
    ")\n",
    "\n",
    "# Replace NULLs with 0 in all flags\n",
    "for c in final_wide.schema.names:\n",
    "    if c.startswith(\"HAS_\") or c.startswith(\"FLAG_SMM_\"):\n",
    "        final_wide = final_wide.with_column(c, coalesce(col(c).cast(\"int\"), lit(0)))\n",
    "\n",
    "final_wide.show(10)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": ["## SMM summary buckets and optional save to Snowflake tables"]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Cell 9 — SMM summary (Exactly 1 / 2 / 3+)\n",
    "smm_flag_cols = [c for c in final_wide.schema.names if c.startswith(\"FLAG_SMM_\")]\n",
    "if smm_flag_cols:\n",
    "    expr = col(smm_flag_cols[0]).cast(\"int\")\n",
    "    for c in smm_flag_cols[1:]:\n",
    "        expr = expr + col(c).cast(\"int\")\n",
    "    wide_sum = final_wide.with_column(\"SMM_COUNT\", expr)\n",
    "\n",
    "    smm_summary = (\n",
    "        wide_sum\n",
    "        .with_column(\n",
    "            \"SMM_BUCKET\",\n",
    "            when(col(\"SMM_COUNT\") == lit(1), lit(\"Exactly 1\"))\n",
    "            .when(col(\"SMM_COUNT\") == lit(2), lit(\"Exactly 2\"))\n",
    "            .when(col(\"SMM_COUNT\") >= lit(3), lit(\"3+\"))\n",
    "            .otherwise(lit(\"0\"))\n",
    "        )\n",
    "        .filter(col(\"SMM_BUCKET\") != lit(\"0\"))\n",
    "        .group_by(\"SMM_BUCKET\")\n",
    "        .agg(sp_sum(lit(1)).alias(\"MEMBERS\"))\n",
    "    )\n",
    "    smm_summary.show()\n",
    "else:\n",
    "    print(\"No FLAG_SMM_* columns found; skipping SMM summary.\")\n",
    "\n",
    "# Optional: persist outputs\n",
    "final_wide.write.mode(\"overwrite\").save_as_table(\"FINAL_WIDE_FLAGS\")\n",
    "if 'smm_summary' in locals():\n",
    "    smm_summary.write.mode(\"overwrite\").save_as_table(\"SMM_SUMMARY\")\n",
    "\n",
    "print(\"Done. Wrote FINAL_WIDE_FLAGS\" + (\", SMM_SUMMARY\" if 'smm_summary' in locals() else \"\"))"
   ],
   "execution_count": null,
   "outputs": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.x"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
