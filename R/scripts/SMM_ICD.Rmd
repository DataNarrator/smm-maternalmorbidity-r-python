---
title: "SMM Indicators & Chronic Condition Flags (Wide Output)"
author: "YPhillipsTaylor"
date: "2025-10-25"
output: html_document
params:
  mm_data_path: "mm_sample_input_long.csv"     # <-- path to your LONG input file
  smm_ref_path: "smm_reference.xlsx"     # <-- path to your reference codes
  write_output_csv: true
  output_csv_path: "member_flags_output.csv"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(janitor)
library(magrittr)
library(maps)
library(digest)
library(tibble)
options(stringsAsFactors = FALSE)
```

# Long-format main dataset:

# One row per member + observation date, with DIAGNOSIS_CODE_1..10 and DIAGNOSIS_DESCRIPTION_SHORT_1..10

```{r}
mm_raw <- readr::read_csv("C:\\Users\\yphillips\\OneDrive - morehouse school of medicine\\smm-maternalmorbidity-r-python\\data\\mm_sample_input_long.csv") %>%
clean_names()
```

```{r}
smm_matches <- read.csv("C:\\Users\\yphillips\\OneDrive - morehouse school of medicine\\smm-maternalmorbidity-r-python\\data\\smm_reference.csv")
```

```{r}
# 1) Get all Georgia county names from maps (lowercase, e.g., "fulton")
ga_counties <- map_data("county") %>%
  filter(region == "georgia") %>%
  distinct(subregion) %>%
  arrange(subregion) %>%
  pull(subregion)

if (length(ga_counties) == 0) {
  stop("No Georgia counties found from maps::map_data('county'). Check that the 'maps' package is installed and loaded.")
}


# 2) Heuristic weights approximating population (metro ATL + big counties get more weight)
metro_weight_lookup <- tibble::tibble(
  county = c(
    # Core ATL metro (very high)
    "fulton","gwinnett","cobb","dekalb",
    # Big/near-metro (high)
    "clayton","cherokee","forsyth","henry","hall","paulding","douglas","rockdale","fayette",
    # Other large counties (mid-high)
    "chatham","richmond","muscogee","coweta","houston","columbia","lowndes","whitfield","floyd","clarke","carroll","newton"
  ),
  weight = c(
    # Core ATL
    16, 14, 12, 12,
    # Near-metro
    8,8,8,8,7,6,6,5,5,
    # Other large
    7,7,7,6,6,6,5,5,5,5,5,5
  )
)

# --- 3) Build county_weights with probabilities & cumulative probs ---
county_weights <- tibble(county = ga_counties) %>%
  left_join(metro_weight_lookup, by = "county") %>%
  mutate(
    weight = coalesce(weight, 1),
    p      = weight / sum(weight),
    cum_p  = cumsum(p)
  )

stopifnot(nrow(county_weights) > 0, !anyNA(county_weights$cum_p))

# --- 4) Hash function: FORCE CHARACTER input ---
hash_to_unit <- function(x) {
  x <- as.character(x)                 # <-- important!
  h <- digest(x, algo = "xxhash64", serialize = FALSE)
  # use first 15 hex chars → [0,1)
  as.numeric(strtoi(substr(h, 1, 15), base = 16)) / (16^15)
}

# --- 5) Build member -> county mapping OUTSIDE mutate (easier to debug) ---
member_keys <- mm_raw %>%
  distinct(dim_member_key) %>%
  mutate(dim_member_key = as.character(dim_member_key))

# sanity check
stopifnot(nrow(member_keys) > 0)

u <- vapply(member_keys$dim_member_key, hash_to_unit, numeric(1))
# Protect against any NA from hashing (shouldn't happen now)
if (anyNA(u)) {
  bad <- member_keys$dim_member_key[is.na(u)]
  warning("Some member keys produced NA hash; assigning them the highest-probability county. Examples: ",
          paste(head(bad, 5), collapse = ", "))
  u[is.na(u)] <- 0  # send them to first cum_p bucket
}

idx <- findInterval(u, county_weights$cum_p) + 1L
idx[idx > nrow(county_weights)] <- nrow(county_weights)  # clamp just in case

```

```{r}
smm_matches <- smm_matches %>%
clean_names() %>%
mutate(
diagnosis = (diagnosis_or_procedure),
) %>% 
filter(diagnosis == "DX") %>%
select(severe_maternal_morbidity_indicator, icd_10, definition) %>%
distinct()
```


# SMM reference (must include: DIAGNOSIS (DX), SMM_INDICATOR, ICD_10)
```{r}
smm_matches_join <- mm_raw %>%
  #filter(!is.na(icd_code_norm), icd_code_norm != "") %>%
  left_join(smm_matches, by = c("icd_10")) %>%
  filter(!is.na(smm_indicator)) %>%
  distinct(dim_member_key, smm_indicator) %>%
  mutate(flag = 1L) %>%
  pivot_wider(
    names_from  = smm_indicator,
    values_from = flag,
    values_fill = 0,
    names_prefix = "flag_smm_"
  )
```

```{r}
# columns to match against
code_cols <- paste0("diagnosis_code_", 1:10)
code_desc_cols <- paste0("diagnosis_description_short_", 1:10)

# 1) Unpivot the 10 code columns
mm_codes_long <- mm_raw %>%
  # pivot both code + description columns at once
  pivot_longer(
    cols = c(all_of(code_cols), all_of(code_desc_cols)),
    names_to = c("type", "slot_id"),
    names_pattern = "^diagnosis_(code|description_short)_(\\d+)$",
    values_to = "val"
  ) %>%
  # spread back out so we have one row per slot with both fields
  pivot_wider(
    names_from  = type,
    values_from = val
  ) %>%
  # tidy up & normalize
  mutate(
    slot_id         = as.integer(slot_id),
    icd_code        = code,
    icd_description = description_short,
    icd_code_norm   = toupper(trimws(icd_code)),
    icd_desc_norm   = tolower(trimws(icd_description))
  ) %>%
  select(dim_member_key, delivery_date, row_date, slot_id, icd_code, icd_code_norm, icd_description, icd_desc_norm)

# 2) Join icd_10 (from smm_matches) to ANY of the 10 codes via the long column
#    Assumes smm_matches has columns icd_10 and smm_indicator
# 1) Helper to normalize ICD strings (apply to BOTH datasets)
normalize_icd <- function(x) {
  x |>
    iconv(from = "", to = "UTF-8", sub = "") |>   # ensure valid UTF-8; drop invalid bytes
    str_replace_all("\\p{Cf}", "") |>             # remove zero-width/format chars
    str_replace_all("\\p{Z}+", " ") |>            # normalize Unicode spaces
    str_replace_all("\\p{Pd}+", "-") |>           # normalize any dash to ASCII hyphen
    trimws() |>
    toupper()
}

# 2) Normalize your long codes table column used for join
mm_codes_long <- mm_codes_long %>%
  mutate(icd_code_norm = normalize_icd(icd_code_norm))

# 3) Normalize the reference icd_10 (in smm_matches or smm_ref_dx)
smm_matches <- smm_matches %>%
  mutate(icd_10 = normalize_icd(icd_10),
    smm_indicator_raw = coalesce(
    suppressWarnings(.$severe_maternal_morbidity_indicator)
    ),
    smm_indicator_raw = tolower(trimws(smm_indicator_raw))) %>%
     filter(!is.na(icd_10), icd_10 != "") %>% 
      select(-any_of(c("severe_maternal_morbidity_indicator")))

# 4) Now the join works
smm_matches_join <- mm_codes_long %>%
  left_join(smm_matches, by = c("icd_code_norm" = "icd_10")) %>% 
    select(-any_of(c("definition", "icd_description")))
```


```{r}
cc_patterns <- c(
  diabetes       = "diabet",
  hypertension   = "hypertens",
  asthma         = "\\basthma\\b",
  copd           = "\\bcopd\\b|chronic obstructive",
  depression     = "depress",
  heart_failure  = "heart failure|cardiac failure|congestive heart failure|\\bchf\\b",
  ischemic       = "ischemi|ischaemi|coronary artery|\\bcad\\b",
  stroke         = "\\bstroke\\b|cerebrovascular|\\bcva\\b|ischemic stroke|hemorrhagic stroke"
)

# Optional ICD-10 code patterns to OR with the description flags
cc_icd_patterns <- list(
  diabetes      = "^E0[8-9]\\.|^E1[0-3]\\.",       # E08–E13.*
  hypertension  = "^I1[0-6]\\.",                    # I10–I16.*
  asthma        = "^J45\\.",                        # J45.*
  copd          = "^J44\\.",                        # J44.*
  depression    = "^F3[2-3]\\.",                    # F32–F33.*
  heart_failure = "^I50\\.|^I11\\.0|^I13\\.(0|2)",  # I50.*, I11.0, I13.0/2
  ischemic      = "^I2[0-5]\\.",                    # I20–I25.*
  stroke        = "^I6[0-9]\\."                     # I60–I69.*
)

# safe detector
str_detect_safe <- function(x, pattern) {
  if (is.null(pattern) || is.na(pattern) || pattern == "") return(rep(FALSE, length(x)))
  stringr::str_detect(replace_na(x, ""), pattern)
}

# Ensure normalized columns exist
smm_matches_join <- smm_matches_join %>%
  mutate(
    icd_desc_norm = tolower(trimws(icd_desc_norm)),
    icd_code_norm = toupper(trimws(icd_code_norm))
  )

# Build flags: description OR ICD code match
for (nm in names(cc_patterns)) {
  text_pat <- cc_patterns[[nm]]
  icd_pat  <- cc_icd_patterns[[nm]]  # use := or <- depending on editor; using <- below
}

smm_matches_join[[paste0("has_", nm)]] <- as.integer(
  str_detect_safe(smm_matches_join$icd_desc_norm, text_pat) |
  str_detect_safe(smm_matches_join$icd_code_norm, icd_pat)
  )

```

```{r}
# 1) Build SMM flags (one column per unique smm_indicator_raw)
smm_flags_wide <- smm_matches_join %>%
  mutate(smm_indicator_raw = tolower(trimws(smm_indicator_raw))) %>%
  filter(!is.na(smm_indicator_raw), smm_indicator_raw != "") %>%
  distinct(dim_member_key, smm_indicator_raw) %>%   # presence implies flag=1
  mutate(flag = 1L) %>%
  pivot_wider(
    names_from  = smm_indicator_raw,
    values_from = flag,
    values_fill = 0,
    names_prefix = "flag_smm_"
  )

# 2) Your existing chronic flags (OR across rows/slots), unchanged
chronic_flags_wide <- smm_matches_join %>%
  group_by(dim_member_key) %>%
  summarise(
    across(starts_with("has_"), ~ as.integer(any(.x == 1, na.rm = TRUE))),
    .groups = "drop"
  )

# 3) Combine: one row per member with chronic + SMM flags
chronic_flags_wide <- chronic_flags_wide %>%
  left_join(smm_flags_wide, by = "dim_member_key") %>%
  mutate(across(starts_with("flag_smm_"), ~ replace_na(.x, 0L)))
```

```{r}
member_demo <- mm_raw %>%
  select(dim_member_key, delivery_date, member_race, member_age, member_zip_code_4) %>%
  group_by(dim_member_key) %>%
  summarise(
    delivery_date       = dplyr::first(na.omit(delivery_date)),
    member_race         = dplyr::first(na.omit(member_race)),
    member_age          = dplyr::first(na.omit(member_age)),
    member_zip_code_4   = dplyr::first(na.omit(member_zip_code_4)),
    .groups = "drop"
  )
```

# --- collapse chronic flags (OR across rows/slots) ---
```{r}
# --- assemble final wide table (one row per member) ---
final_wide <- chronic_flags_wide %>%
  left_join(member_demo,           by = "dim_member_key") %>%
  left_join(smm_indicator_by_member, by = "dim_member_key") %>%
  mutate(across(starts_with("has_"), ~ replace_na(.x, 0L))) %>%
  relocate(dim_member_key, delivery_date, member_race, member_age, member_zip_code_4, smm_indicator_raw)
```

```{r}
# preview
glimpse(final_wide)

head(final_wide,10)

skimr::skim(final_wide)
```

# summaries on final_wide df
```{r}

# Identify SMM flag columns
smm_flag_cols <- final_wide %>% select(starts_with("flag_smm_")) %>% names()
stopifnot(length(smm_flag_cols) > 0)

final_wide_sum <- final_wide %>%
  mutate(
    smm_count = rowSums(across(all_of(smm_flag_cols), ~ as.integer(.x %in% c(1, TRUE))), na.rm = TRUE)
  )

smm_summary <- final_wide_sum %>%
  mutate(
    smm_bucket = case_when(
      smm_count == 1 ~ "Exactly 1",
      smm_count == 2 ~ "Exactly 2",
      smm_count >= 3 ~ "3+",
      TRUE           ~ "0"
    )
  ) %>%
  filter(smm_bucket != "0") %>%
  count(smm_bucket, name = "members") %>%
  arrange(factor(smm_bucket, levels = c("Exactly 1", "Exactly 2", "3+")))

print(smm_summary)
```


# Add county to the member file *county will be on real data)
```{r}
# Get the list of Georgia counties from the maps package
ga_map <- map_data("county") %>% 
  dplyr::filter(region == "georgia")

ga_counties <- ga_map %>% 
  dplyr::distinct(subregion) %>% 
  dplyr::arrange(subregion) %>% 
  dplyr::pull(subregion)  # lowercase county names (e.g., "fulton")

# Deterministically assign a GA county to each member (adds a new column ONLY)
# This preserves all existing columns/values.
# If you have a real county source, replace the mutate() with your join/mapping.
mm_raw1 <- mm_raw %>%
  mutate(
    county = ga_counties[(as.integer(factor(dim_member_key)) - 1) %% length(ga_counties) + 1]
  )

# If your pipeline builds final_wide later from mm_raw/member_demo,
# the county will flow through when you select/join demographics.
# If final_wide already exists, add county now (one per member):
member_county <- mm_raw %>%
  select(dim_member_key, county) %>%
  group_by(dim_member_key) %>%
  summarise(county = dplyr::first(na.omit(county)), .groups = "drop")

final_wide <- final_wide %>%
  left_join(member_county, by = "dim_member_key")
```

```{r}
library(ggplot2)

# Aggregate counts by county from final_wide (joined with county via dim_member_key)
# If `final_wide` already includes the county, skip the join
member_county <- mm_raw %>%
  distinct(dim_member_key, county)

county_counts <- final_wide %>%
  group_by(county) %>%
  summarise(members = dplyr::n(), .groups = "drop") %>%
  mutate(county = tolower(county))

ga_map <- map_data("county") %>%
  filter(region == "georgia") %>%
  mutate(county = subregion)

ga_choro <- ga_map %>%
  left_join(county_counts, by = "county")

ggplot(ga_choro, aes(long, lat, group = group, fill = members)) +
  geom_polygon(color = "white", linewidth = 0.2) +
  coord_quickmap() +
  labs(
    title = "Members by County — Georgia",
    fill  = "Members"
  ) +
  theme_void()
```

